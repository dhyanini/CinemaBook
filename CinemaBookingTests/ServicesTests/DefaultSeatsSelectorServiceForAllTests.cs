using CinemaBookingCore.Services;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Xunit;
using static CinemaBookingCore.Utilities.Constants;

namespace CinemaBookingTests
{
    public class DefaultSeatsSelectorServiceForAllTests
    {
        private SeatingMapService sp = SeatingMapService.Instance;
        private CinemaSeatsSelectorService dfs = CinemaSeatsSelectorService.Instance;

        //Integration Tests

        [Theory]
        [InlineData(13, 8, 10)]       
        public void GetSeatsSelection_WhenAllRowsAreEmptyAndRequiredSeatsLessThanRowSeats_ReturnsMiddleMostPossibleSeats
            (int seatsToBook, int totalRows, int totalCols)
        {
            //Arrange
            int[,] expected = new int[8, 10] { 
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE }, 
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE }, 
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE }, 
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE }, 
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, ALLOCATED, ALLOCATED, ALLOCATED, AVAILABLE, AVAILABLE, AVAILABLE },
                { ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED }};

            //Act
            var seats = sp.BuildSeatingMap(totalRows, totalCols);
            var seatsAllocated = dfs.GetSeats(seatsToBook, seats.GetLength(0)-1, null , seats);

            Assert.Equal(seatsAllocated, expected);
        }

        [Theory]
        [InlineData(11, 7, 5, 8, 10)]
        public void GetSeatsSelection_WhenAllRowsAreEmptyAndPreferredSeatGiven_ReturnsMiddleMostPossibleSeats
            (int seatsToBook, int startRow, int startCol, int totalRows, int totalCols)
        {
            //Arrange
            int[,] expected = new int[8, 10] {
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE }};

            //Act
            var seats = sp.BuildSeatingMap(totalRows, totalCols);
            var seatsAllocated = dfs.GetSeats(seatsToBook, startRow - 1, startCol -1 , seats);

            Assert.Equal(seatsAllocated, expected);
        }

        [Theory]
        [InlineData(13)]
        public void GetSeatsSelection_WhenAllRowsAreNonEmptyAndRequiredSeatsLessThanRowSeats_ReturnsMiddleMostPossibleSeats
           (int seatsToBook)
        {
            //Arrange
            int[,] input = new int[8, 10] {
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, OCCUPIED, OCCUPIED, OCCUPIED, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, AVAILABLE, AVAILABLE }};

            int[,] expected = new int[8, 10] {
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, ALLOCATED, ALLOCATED, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { ALLOCATED, ALLOCATED, ALLOCATED, ALLOCATED, OCCUPIED, OCCUPIED, OCCUPIED, ALLOCATED, ALLOCATED, ALLOCATED },
                { ALLOCATED, ALLOCATED, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, ALLOCATED, ALLOCATED }};

            //Act
            var seatsAllocated = dfs.GetSeats(seatsToBook, input.GetLength(0) - 1, null, input);

            Assert.Equal(seatsAllocated, expected);
        }

        [Theory]
        [InlineData(11, 7, 5)]
        public void GetSeatsSelection_WhenAllRowsAreNonEmptyAndPreferredSeatGiven_ReturnsMiddleMostPossibleSeats
            (int seatsToBook, int startRow, int startCol)
        {
            //Arrange
            int[,] input = new int[8, 10] {
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { OCCUPIED, AVAILABLE, AVAILABLE, OCCUPIED, AVAILABLE, AVAILABLE, OCCUPIED, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, OCCUPIED, OCCUPIED, OCCUPIED, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, AVAILABLE, AVAILABLE }};


            int[,] expected = new int[8, 10] {
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, ALLOCATED, AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE },
                { OCCUPIED, ALLOCATED, ALLOCATED, OCCUPIED, ALLOCATED, ALLOCATED, OCCUPIED, ALLOCATED, ALLOCATED, ALLOCATED },
                { AVAILABLE, AVAILABLE, AVAILABLE, AVAILABLE, OCCUPIED, OCCUPIED, OCCUPIED, ALLOCATED, ALLOCATED, ALLOCATED },
                { AVAILABLE, AVAILABLE, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, OCCUPIED, AVAILABLE, AVAILABLE }};

            //Act
            var seatsAllocated = dfs.GetSeats(seatsToBook, startRow - 1, startCol - 1, input);

            Assert.Equal(seatsAllocated, expected);
        }
    }
}
